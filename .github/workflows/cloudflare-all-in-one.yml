name: Apply Cloudflare Security Settings

on:
  workflow_dispatch:
  schedule:
    - cron: '0 0 * * *' # Runs every day at midnight UTC

jobs:
  apply-security-settings:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Set up dependencies
        run: |
          echo "Installing dependencies..."
          sudo apt-get update
          sudo apt-get install -y jq yq curl

      - name: Install and Configure CrowdSec
        run: |
          echo "Installing CrowdSec..."
          curl -sL https://packagecloud.io/crowdsec/crowdsec/gpgkey | sudo apt-key add -
          echo "deb https://packagecloud.io/crowdsec/crowdsec/ubuntu/ focal main" | sudo tee /etc/apt/sources.list.d/crowdsec.list
          sudo apt-get update
          sudo apt-get install -y crowdsec

          echo "Configuring CrowdSec..."
          sudo cscli collections install crowdsecurity/linux
          sudo systemctl enable crowdsec
          sudo systemctl start crowdsec

      - name: Fetch CrowdSec Banned IPs
        id: fetch-crowdsec-ips
        run: |
          echo "Fetching banned IP addresses from CrowdSec..."
          sudo cscli decisions list -o json | jq -r '.[].value' > banned_ips.txt
          echo "Banned IPs list created."

      - name: Check and Create Subdomain on Cloudflare
        id: check-create-subdomain
        run: |
          echo "Checking if the subdomain exists on Cloudflare..."
          DOMAIN="${{ vars.DOMAIN }}"
          CLOUDFLARE_API_TOKEN="${{ secrets.CLOUDFLARE_API_TOKEN }}"
          CLOUDFLARE_ZONE_ID="${{ vars.CLOUDFLARE_ZONE_ID }}"
          DNS_RECORD_TYPE="${{ vars.DNS_RECORD_TYPE }}"
          DNS_RECORD_VALUE="${{ vars.DNS_RECORD_VALUE }}"

          # Check if the DNS record for the subdomain exists
          RECORD_CHECK_RESPONSE=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records?name=$DOMAIN" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            -H "Content-Type: application/json")

          RECORD_EXISTS=$(echo $RECORD_CHECK_RESPONSE | jq -r '.result | length')

          if [[ "$RECORD_EXISTS" -eq 0 ]]; then
            echo "DNS record for $DOMAIN does not exist. Creating it..."
            
            # Create the DNS record based on the specified type and value
            CREATE_RECORD_RESPONSE=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records" \
              -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data '{
                "type": "'$DNS_RECORD_TYPE'",
                "name": "'$DOMAIN'",
                "content": "'$DNS_RECORD_VALUE'",
                "ttl": 1,
                "proxied": false
              }')
            
            if [[ $(echo $CREATE_RECORD_RESPONSE | jq -r '.success') == "true" ]]; then
              echo "Subdomain $DOMAIN created as $DNS_RECORD_TYPE record with value $DNS_RECORD_VALUE."
            else
              echo "Failed to create subdomain $DOMAIN: $(echo $CREATE_RECORD_RESPONSE | jq -r '.errors[] | .message')" >&2
              exit 1
            fi
          else
            echo "DNS record for $DOMAIN already exists."
          fi

      - name: Apply security settings
        run: |
          set -e  # Exit on any error

          API_URL="https://api.cloudflare.com/client/v4/zones/${{ vars.CLOUDFLARE_ZONE_ID }}/settings"
          HEADERS="-H \"Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}\" -H \"Content-Type: application/json\""

          apply_setting() {
            local ENDPOINT=$1
            local DATA=$2
            local SUCCESS_MESSAGE=$3

            RESPONSE=$(curl -s -X PATCH "$ENDPOINT" $HEADERS --data "$DATA")
            if [[ $(echo "$RESPONSE" | jq -r '.success') == "true" ]]; then
              echo "$SUCCESS_MESSAGE"
            else
              echo "Error applying $SUCCESS_MESSAGE: $RESPONSE" >&2
              exit 1
            fi
          }

          # Apply HTTP/3 setting
          if [[ "${{ vars.ENABLE_HTTP3 }}" == "true" ]]; then
            apply_setting "$API_URL" '{"http3":{"value":true}}' "HTTP/3 enabled."
          fi

          # Apply HSTS setting
          if [[ "${{ vars.ENABLE_HSTS }}" == "true" ]]; then
            apply_setting "$API_URL/security_header" \
              '{"strict_transport_security": {"enabled": true, "max_age": '${{ vars.HSTS_MAX_AGE }}', "include_subdomains": true, "preload": true}}' \
              "HSTS enabled."
          fi

          # Apply TLS minimum version setting
          apply_setting "$API_URL" '{"min_tls_version":{"value":"${{ vars.TLS_MIN_VERSION }}"},"tls_1_2_only":{"value":true}}' \
            "TLS minimum version set to ${{ vars.TLS_MIN_VERSION }}."

          # Apply secure ciphers setting
          apply_setting "$API_URL" '{"cipher_suite":{"value":"${{ vars.SECURE_CIPHERS }}"},"cipher_suites_legacy":{"value":false}}' \
            "Secure ciphers applied."

          # Apply DDoS protection setting
          if [[ "${{ vars.ENABLE_DDOS_PROTECTION }}" == "true" ]]; then
            apply_setting "$API_URL" '{"ddos_protection":{"value":"true"}}' "DDoS protection enabled."
          fi

          # Apply WAF setting
          if [[ "${{ vars.ENABLE_WAF }}" == "true" ]]; then
            apply_setting "$API_URL" '{"web_application_firewall":{"value":"true"}}' "Web Application Firewall enabled."
          fi

          # Apply DNSSEC setting
          if [[ "${{ vars.ENABLE_DNSSEC }}" == "true" ]]; then
            apply_setting "https://api.cloudflare.com/client/v4/zones/${{ vars.CLOUDFLARE_ZONE_ID }}/dnssec" \
              '{"status":"active"}' "DNSSEC enabled."
          fi

          # Apply HTTPS rewrites setting
          if [[ "${{ vars.ENABLE_HTTPS_REWRITES }}" == "true" ]]; then
            apply_setting "$API_URL" '{"automatic_https_rewrites":{"value":true}}' "Automatic HTTPS Rewrites enabled."
          fi

          # Apply Geo-Blocking settings
          if [[ "${{ vars.GEO_BLOCKING_ENABLED }}" == "true" ]]; then
            echo "Configuring Geo-Blocking..."
            IFS=',' read -ra COUNTRIES <<< "${{ vars.GEO_BLOCKING_COUNTRIES }}"
            for COUNTRY in "${COUNTRIES[@]}"; do
              curl -X POST "https://api.cloudflare.com/client/v4/zones/${{ vars.CLOUDFLARE_ZONE_ID }}/firewall/rules" \
                $HEADERS --data '{
                  "action": "block",
                  "filter": {
                    "expression": "ip.geoip.country eq \"'$COUNTRY'\"",
                    "description": "Block traffic from '$COUNTRY'"
                  }
                }'
              echo "Blocking traffic from $COUNTRY."
            done
          fi

          # Apply Firewall rules
          echo "Applying Firewall Rules..."
          echo "${{ vars.FIREWALL_RULES }}" | jq -c '.[]' | while read -r RULE; do
            ACTION=$(echo $RULE | jq -r '.action')
            EXPRESSION=$(echo $RULE | jq -r '.expression')
            curl -X POST "https://api.cloudflare.com/client/v4/zones/${{ vars.CLOUDFLARE_ZONE_ID }}/firewall/rules" \
              $HEADERS --data '{
                "action": "'"$ACTION"'",
                "filter": {
                  "expression": "'"$EXPRESSION"'",
                  "description": "'"$ACTION"' traffic matching rule"
                }
              }'
            echo "$ACTION traffic matching rule applied: $EXPRESSION"
          done

          # Apply Custom Header settings
          if [[ "${{ vars.CUSTOM_HEADER_ENABLED }}" == "true" ]]; then
            echo "Setting custom header..."
            curl -X POST "https://api.cloudflare.com/client/v4/zones/${{ vars.CLOUDFLARE_ZONE_ID }}/pagerules" \
              $HEADERS --data '{
                "targets": [
                  {
                    "target": "url",
                    "constraint": {
                      "operator": "matches",
                      "value": "*.'${{ vars.DOMAIN }}'/*"
                    }
                  }
                ],
                "actions": [
                  {
                    "id": "set_header",
                    "value": {
                      "headers": [
                        {
                          "name": "'"${{ vars.CUSTOM_HEADER_KEY }}"'",
                          "value": "'"${{ vars.CUSTOM_HEADER_VALUE }}"'"
                        }
                      ]
                    }
                  }
                ],
                "priority": 1,
                "status": "active"
              }'
            echo "Custom header set: ${{ vars.CUSTOM_HEADER_KEY }}: ${{ vars.CUSTOM_HEADER_VALUE }}"

          # Apply Rate Limiting Rule
          echo "Setting up rate limiting rule..."
          RATE_LIMIT_URL="https://api.cloudflare.com/client/v4/zones/${{ vars.CLOUDFLARE_ZONE_ID }}/rate_limits"
          RATE_LIMIT_RULE=$(cat <<EOF
{
  "threshold": 1000,
  "period": 60,
  "action": {
    "mode": "simulate",
    "timeout": 60,
    "response": {
      "content_type": "text/plain",
      "body": "This request has been rate-limited."
    }
  },
  "match": {
    "request": {
      "methods": ["GET"]
    },
    "response": {
      "origin_traffic": true,
      "headers": [
        {
          "name": "cf-ray",
          "op": "exists"
        }
      ]
    },
    "url": "*"
  },
  "enabled": true,
  "description": "Rate limit rule to limit to 1000 requests per minute for GET requests"
}
EOF
)
          RESPONSE=$(curl -s -X POST "$RATE_LIMIT_URL" $HEADERS --data "$RATE_LIMIT_RULE")
          if [[ $(echo "$RESPONSE" | jq -r '.success') == "true" ]]; then
            echo "Rate limiting rule applied successfully."
          else
            echo "Failed to apply rate limiting rule: $(echo "$RESPONSE" | jq -r '.errors[] | .message')" >&2
            exit 1
          fi
          fi

          # Apply CrowdSec Banned IPs
          if [[ -f "banned_ips.txt" ]]; then
            echo "Applying CrowdSec Banned IPs..."
            while IFS= read -r IP; do
              curl -X POST "https://api.cloudflare.com/client/v4/zones/${{ vars.CLOUDFLARE_ZONE_ID }}/firewall/access_rules/rules" \
                $HEADERS --data '{
                  "mode": "block",
                  "configuration": {
                    "target": "ip",
                    "value": "'"$IP"'"
                  },
                  "notes": "Blocked by CrowdSec"
                }'
              echo "Blocked IP $IP from CrowdSec list."
            done < banned_ips.txt
          else
            echo "No banned IPs file found."
          fi

      - name: Post-Action Cleanup
        if: always()
        run: |
          echo "Cleaning up..."
          rm -f banned_ips.txt
